<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BUGFIX_DUPLICATE_ATTACKS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BUGFIX_DUPLICATE_ATTACKS.md" />
              <option name="updatedContent" value="#  Bug Fix: Duplicate Attack Requests&#10;&#10;## Problema&#10;Utilizatorii puteau face click repetat pe aceeași celulă, trimițând multiple atacuri duplicate către backend, chiar dacă celula fusese deja atacată. Backend-ul răspundea corect cu mesajul `ATTACK_ERROR`, dar frontend-ul continua să trimită requesturi.&#10;&#10;### Simptome&#10;- Click pe o celulă → trimite atac&#10;- Click din nou pe aceeași celulă → trimite atac duplicat&#10;- Backend răspunde cu `ATTACK_ERROR: &quot;This cell was already attacked!&quot;`&#10;- UI-ul nu previne click-urile duplicate&#10;- Spam de requesturi WebSocket către backend&#10;&#10;### Log-uri Observate&#10;```&#10;SEND: /app/game/{roomId}/attack&#10;{&quot;playerId&quot;:&quot;...&quot;, &quot;row&quot;:8, &quot;col&quot;:3}&#10;&#10;MESSAGE: ATTACK_ERROR&#10;{&quot;col&quot;:3, &quot;message&quot;:&quot;This cell was already attacked!&quot;, &quot;row&quot;:8, &quot;type&quot;:&quot;ATTACK_ERROR&quot;}&#10;&#10;// Repetat de multiple ori pentru aceeași celulă&#10;```&#10;&#10;## Cauza Rădăcină&#10;În `Game.tsx`, funcția `handleCellClick` **nu verifica** dacă celula fusese deja atacată înainte de a trimite atacul către backend.&#10;&#10;```typescript&#10;// ❌ COD VECHI - Fără verificare&#10;const handleCellClick = (row: number, col: number) =&gt; {&#10;    if (!isMyTurn || gamePhase !== 'playing') {&#10;        return;&#10;    }&#10;&#10;    // Trimite direct atacul fără să verifice dacă celula a fost atacată&#10;    stompClientRef.current?.publish({&#10;        destination: `/app/game/${roomId}/attack`,&#10;        body: JSON.stringify({ playerId: user?.id, row, col })&#10;    });&#10;};&#10;```&#10;&#10;## Soluția Implementată&#10;&#10;### 1. Verificare în `handleCellClick` (Game.tsx)&#10;Adăugat verificare pentru a preveni atacurile duplicate:&#10;&#10;```typescript&#10;// ✅ COD NOU - Cu verificare&#10;const handleCellClick = (row: number, col: number) =&gt; {&#10;    if (!isMyTurn || gamePhase !== 'playing') {&#10;        console.log('❌ Not your turn or game not started');&#10;        return;&#10;    }&#10;&#10;    // ✅ VERIFICARE NOUĂ: Verifică dacă celula a fost deja atacată&#10;    const alreadyAttacked = myAttacks.some(&#10;        attack =&gt; attack.row === row &amp;&amp; attack.col === col&#10;    );&#10;    if (alreadyAttacked) {&#10;        console.log('❌ Cell already attacked', { row, col });&#10;        return;&#10;    }&#10;&#10;    console.log(` Attacking cell: [${row}, ${col}]`);&#10;&#10;    // Trimite atacul doar dacă celula nu a fost atacată&#10;    stompClientRef.current?.publish({&#10;        destination: `/app/game/${roomId}/attack`,&#10;        body: JSON.stringify({ playerId: user?.id, row, col })&#10;    });&#10;};&#10;```&#10;&#10;### 2. Handler pentru `ATTACK_ERROR` Messages&#10;Adăugat handler pentru mesajele de eroare de la backend:&#10;&#10;```typescript&#10;// În subscribe handler&#10;else if (payload.type === 'ATTACK_ERROR') {&#10;    // Handle attack error (e.g., cell already attacked)&#10;    console.warn('⚠️ Attack error:', payload.message, { &#10;        row: payload.row, &#10;        col: payload.col &#10;    });&#10;    // Frontend check should prevent this, but log it if it happens&#10;}&#10;```&#10;&#10;### 3. Verificare Dublă în GameBoard3D.tsx&#10;Board-ul deja avea o verificare la nivel de UI:&#10;&#10;```typescript&#10;// În GameBoard3D.tsx - handleCellClick&#10;const cellState = board[row][col];&#10;if (cellState === 'hit' || cellState === 'miss') {&#10;    console.log('❌ Cell already attacked!', { row, col, state: cellState });&#10;    return;&#10;}&#10;```&#10;&#10;## Nivele de Protecție&#10;&#10;Acum avem **3 nivele** de protecție împotriva atacurilor duplicate:&#10;&#10;1. **UI Layer** (GameBoard3D.tsx): Celulele atacate sunt marcate vizual și nu sunt clickable&#10;2. **Logic Layer** (Game.tsx): `handleCellClick` verifică `myAttacks` array înainte de a trimite&#10;3. **Backend Layer** (GameController.java): Validează și refuză atacurile duplicate&#10;&#10;## Testare&#10;&#10;### Pași de Test&#10;1. ✅ Începe un joc și plasează navele&#10;2. ✅ Atacă o celulă (ar trebui să trimită un singur request)&#10;3. ✅ Încearcă să ataci aceeași celulă din nou&#10;4. ✅ **Așteptat**: Click-ul nu trimite niciun request&#10;5. ✅ **Așteptat**: Consola arată &quot;❌ Cell already attacked&quot;&#10;6. ✅ **Așteptat**: Backend nu primește request duplicate&#10;&#10;### Scenarii Testate&#10;- ✅ Click simplu pe celulă nouă → funcționează&#10;- ✅ Click repetat pe celulă atacată → blocat&#10;- ✅ Click rapid pe aceeași celulă → blocat&#10;- ✅ Hit urmată de click din nou → blocat&#10;- ✅ Miss urmată de click din nou → blocat&#10;&#10;## Impact&#10;&#10;### Înainte&#10;- ❌ Spam de requesturi WebSocket&#10;- ❌ Backend procesează requesturi inutile&#10;- ❌ Log-uri pline de ATTACK_ERROR&#10;- ❌ UX confuz (celula &quot;respinge&quot; click-urile)&#10;&#10;### După&#10;- ✅ Un singur request per celulă&#10;- ✅ Backend nu primește requesturi duplicate&#10;- ✅ Log-uri curate&#10;- ✅ UX clar - celulele atacate sunt disabled vizual&#10;&#10;## Files Modified&#10;1. `/frontend/src/pages/Game.tsx`&#10;   - Adăugat verificare în `handleCellClick`&#10;   - Adăugat handler pentru `ATTACK_ERROR`&#10;2. `/frontend/src/components/GameBoard3D.tsx`&#10;   - Verificare existentă confirmată și funcțională&#10;&#10;## Commit Message Sugerat&#10;```&#10;fix: prevent duplicate attack requests on same cell&#10;&#10;- Add check in handleCellClick to prevent attacking already-attacked cells&#10;- Add ATTACK_ERROR message handler for better error logging&#10;- Leverage existing UI-level protection in GameBoard3D&#10;- Reduces WebSocket spam and improves UX&#10;&#10;Fixes issue where clicking on the same cell multiple times would&#10;send duplicate attack requests to backend, even though backend&#10;correctly rejected them with ATTACK_ERROR.&#10;```&#10;&#10;---&#10;&#10;**Fix aplicat**: 2025-01-06  &#10;**Status**: ✅ Rezolvat  &#10;**Severity**: Medium (UX issue + network spam)  &#10;**Priority**: High (afectează gameplay)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/GAME_RULES_IMPLEMENTED.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/GAME_RULES_IMPLEMENTED.md" />
              <option name="updatedContent" value="# Reguli de Joc Implementate - Battleship&#10;&#10;## ✅ Toate Regulile Implementate:&#10;&#10;### 1. **Dacă este tura oponentului, nu poți apăsa pe board** &#10;&#10;**Frontend (`GameBoard3D.tsx`):**&#10;- Adăugat prop `isClickable` la componenta `GameBoard3D`&#10;- WaterCell verifică `isClickable` înainte de a permite click&#10;- Cursor schimbat în &quot;not-allowed&quot; când nu e tura ta&#10;- Console log: ` Board is not clickable - not your turn!`&#10;&#10;**Cod:**&#10;```typescript&#10;// În BoardGrid&#10;const handleCellClick = (row: number, col: number) =&gt; {&#10;    if (!isClickable) {&#10;        console.log(' Board is not clickable - not your turn!');&#10;        return;&#10;    }&#10;    // ...&#10;}&#10;&#10;// În WaterCell&#10;const canClick = isClickable &amp;&amp; state === 'empty';&#10;&lt;mesh onClick={canClick ? onClick : undefined} /&gt;&#10;```&#10;&#10;**Utilizare în Game.tsx:**&#10;```typescript&#10;&lt;GameBoard3D&#10;    isPlayerBoard={false}&#10;    boardSize={10}&#10;    onCellClick={handleCellClick}&#10;    isClickable={isMyTurn}  // ✅ Doar când e tura ta&#10;/&gt;&#10;```&#10;&#10;---&#10;&#10;### 2. **Dacă lovești o navă, ai încă o tură** &#10;&#10;**Backend (`GameController.java`):**&#10;- Detectează dacă atacul lovește o navă comparând coordonatele cu pozițiile navelor adversarului&#10;- Trimite `isHit: true/false` în mesajul ATTACK&#10;- **Dacă MISS** → schimbă tura (trimite TURN_CHANGE)&#10;- **Dacă HIT** → păstrează tura (trimite TURN_KEEP)&#10;&#10;**Cod:**&#10;```java&#10;// Check if attack hits any ship&#10;boolean isHit = false;&#10;for (Map&lt;String, Object&gt; ship : defenderShips) {&#10;    List&lt;Map&lt;String, Object&gt;&gt; positions = ship.get(&quot;positions&quot;);&#10;    for (Map&lt;String, Object&gt; pos : positions) {&#10;        if (shipRow == row &amp;&amp; shipCol == col) {&#10;            isHit = true;&#10;            break;&#10;        }&#10;    }&#10;}&#10;&#10;// Only change turn if MISS&#10;if (!isHit) {&#10;    roomCurrentTurn.put(roomId, nextPlayer);&#10;    messagingTemplate.convertAndSend(&quot;/topic/game/&quot; + roomId, turnChangeMessage);&#10;} else {&#10;    // HIT - attacker keeps the turn&#10;    messagingTemplate.convertAndSend(&quot;/topic/game/&quot; + roomId, turnKeepMessage);&#10;}&#10;```&#10;&#10;**Frontend (`Game.tsx`):**&#10;```typescript&#10;else if (payload.type === 'TURN_KEEP') {&#10;    console.log(' HIT! Keep the turn:', payload);&#10;    setIsMyTurn(payload.currentPlayer === user?.id);&#10;}&#10;```&#10;&#10;**Logs Expected:**&#10;- **La HIT:** ` HIT! Keep the turn:` → Rămâi la tură&#10;- **La MISS:** ` Turn changed:` → Tura trece la adversar&#10;&#10;---&#10;&#10;### 3. **Nu poți lovi aceeași parte a navei de 2 ori** ❌&#10;&#10;**Frontend (`GameBoard3D.tsx`):**&#10;- Verifică `cellState` înainte de a permite click&#10;- Dacă celula e `'hit'` sau `'miss'`, ignoră click-ul&#10;- Console log: `❌ Cell already attacked!`&#10;&#10;**Cod:**&#10;```typescript&#10;const handleCellClick = (row: number, col: number) =&gt; {&#10;    if (!isClickable) {&#10;        console.log(' Board is not clickable - not your turn!');&#10;        return;&#10;    }&#10;    &#10;    const cellState = board[row][col];&#10;    if (cellState === 'hit' || cellState === 'miss') {&#10;        console.log('❌ Cell already attacked!', { row, col, state: cellState });&#10;        return; // ✅ Previne re-atacarea&#10;    }&#10;    &#10;    if (onCellClick) {&#10;        onCellClick(row, col);&#10;    }&#10;}&#10;```&#10;&#10;**WaterCell - Visual Feedback:**&#10;```typescript&#10;const canClick = isClickable &amp;&amp; state === 'empty';&#10;onPointerOver={() =&gt; {&#10;    if (canClick) {&#10;        document.body.style.cursor = 'pointer';&#10;    } else {&#10;        document.body.style.cursor = 'not-allowed'; // ✅ Cursor diferit&#10;    }&#10;}}&#10;```&#10;&#10;**Backend (`GameController.java`):**&#10;- Track toate celulele atacate în `roomAttackedCells`&#10;- Verifică dacă celula a fost deja atacată&#10;- Respinge atacul dacă e duplicat&#10;&#10;**Cod:**&#10;```java&#10;// Track attacked cells: roomId -&gt; Set&lt;&quot;row,col&quot;&gt;&#10;private final Map&lt;String, Set&lt;String&gt;&gt; roomAttackedCells = new ConcurrentHashMap&lt;&gt;();&#10;&#10;// In attack method&#10;String cellKey = row + &quot;,&quot; + col;&#10;if (attackedCells.contains(cellKey)) {&#10;    log.warn(&quot;Cell already attacked!&quot;);&#10;    // Send error message&#10;    return; // ✅ Reject duplicate attack&#10;}&#10;attackedCells.add(cellKey); // ✅ Mark as attacked&#10;```&#10;&#10;---&#10;&#10;### 4. **Nu poți pune o navă peste alta la plasare** &#10;&#10;**Frontend (`ShipPlacement.tsx`):**&#10;- `isCellOccupied()` verifică dacă celula e deja ocupată de o navă plasată&#10;- `isValidPlacement()` verifică fiecare celulă unde ar fi nava&#10;- Returnează `false` dacă oricare celulă e ocupată sau out of bounds&#10;&#10;**Cod:**&#10;```typescript&#10;const isCellOccupied = (row: number, col: number): boolean =&gt; {&#10;    return placedShips.some(ship =&gt;&#10;        ship.positions.some(pos =&gt; pos.row === row &amp;&amp; pos.col === col)&#10;    );&#10;};&#10;&#10;const isValidPlacement = (row, col, size, orient): boolean =&gt; {&#10;    for (let i = 0; i &lt; size; i++) {&#10;        const r = orient === 'vertical' ? row + i : row;&#10;        const c = orient === 'horizontal' ? col + i : col;&#10;        &#10;        // Check boundaries&#10;        if (r &gt;= boardSize || c &gt;= boardSize || r &lt; 0 || c &lt; 0) {&#10;            return false;&#10;        }&#10;        &#10;        // Check if occupied ✅&#10;        if (isCellOccupied(r, c)) {&#10;            return false;&#10;        }&#10;    }&#10;    return true;&#10;};&#10;```&#10;&#10;**Visual Feedback:**&#10;```typescript&#10;// În grid rendering&#10;className={`&#10;    ${isOccupied &#10;        ? 'bg-green-500/40 border-green-500'      // ✅ Navă plasată&#10;        : isHovered&#10;            ? canPlace&#10;                ? 'bg-cyan-500/40 border-cyan-500' // ✅ Plasare validă&#10;                : 'bg-red-500/40 border-red-500'   // ❌ Plasare invalidă (peste altă navă)&#10;            : 'bg-blue-900/30'&#10;    }&#10;`}&#10;```&#10;&#10;**Error Message:**&#10;```typescript&#10;const handleCellClick = (row, col) =&gt; {&#10;    if (!selectedShip || !canPlace) {&#10;        if (!canPlace &amp;&amp; selectedShip) {&#10;            console.warn('❌ Cannot place ship here - overlaps with another ship!');&#10;        }&#10;        return;&#10;    }&#10;    // ... place ship&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Rezumat Validări:&#10;&#10;| Regulă | Frontend | Backend | Visual Feedback |&#10;|--------|----------|---------|-----------------|&#10;| Nu apăsa când nu e tura ta | ✅ `isClickable` | ✅ Validare turn |  Cursor &quot;not-allowed&quot; |&#10;| HIT → keep turn | ✅ Handler `TURN_KEEP` | ✅ Detectare hit, păstrare turn |  Console log |&#10;| Nu re-ataca același loc | ✅ Check `cellState` | ✅ Track `attackedCells` | ❌ Console log + cursor |&#10;| Nu plasa navă peste navă | ✅ `isCellOccupied` | N/A (frontend only) |  Roșu când invalid |&#10;&#10;---&#10;&#10;##  Flow de Joc Complet:&#10;&#10;### Plasare Nave:&#10;1. **Selectează navă** → Click pe navă în listă&#10;2. **Rotește** → Click &quot;Rotate&quot; (Horizontal ↔ Vertical)&#10;3. **Hover pe grid** → Vezi preview (Verde = OK, Roșu = Invalid)&#10;4. **Click pe grid** → Plasează nava&#10;5. **Verificare** → `isValidPlacement()` previne suprapunere&#10;6. **Repeat** → Până toate navele sunt plasate&#10;7. **Ready** → Click &quot;Ready for Battle&quot;&#10;&#10;### Joc Activ:&#10;&#10;**Tura ta (isMyTurn = true):**&#10;1. Board adversar → `isClickable = true`&#10;2. Click pe celulă → Trimite attack la server&#10;3. Server verifică:&#10;   - E tura ta? ✅&#10;   - Celula atacată deja? ❌ Reject&#10;   - Hit sau Miss?&#10;4. **Dacă HIT:**&#10;   - Server trimite `TURN_KEEP`&#10;   - `isMyTurn` rămâne `true`&#10;   - Poți ataca din nou! &#10;5. **Dacă MISS:**&#10;   - Server trimite `TURN_CHANGE`&#10;   - `isMyTurn = false`&#10;   - Board devine `isClickable = false` &#10;&#10;**Tura adversarului (isMyTurn = false):**&#10;1. Board adversar → `isClickable = false`&#10;2. Hover → Cursor &quot;not-allowed&quot;&#10;3. Click → Ignorat cu log ` Board is not clickable`&#10;4. Așteaptă `TURN_CHANGE` de la server&#10;5. Când primești turn → `isMyTurn = true`&#10;&#10;---&#10;&#10;##  Testare:&#10;&#10;### Test 1: Nu poți apăsa când nu e tura ta&#10;```&#10;1. Jucător 1 atacă → Miss&#10;2. Devine tura Jucătorului 2&#10;3. Jucător 1 încearcă să atace din nou&#10;✅ Expected: Console log &quot; Board is not clickable&quot;&#10;✅ Expected: Cursor &quot;not-allowed&quot;&#10;```&#10;&#10;### Test 2: HIT păstrează tura&#10;```&#10;1. Jucător 1 atacă celula cu navă&#10;2. Server detectează HIT&#10;✅ Expected: Console log &quot; HIT! Keep the turn&quot;&#10;✅ Expected: isMyTurn rămâne true&#10;✅ Expected: Board-ul rămâne clickable&#10;3. Jucător 1 poate ataca din nou imediat&#10;```&#10;&#10;### Test 3: Nu poți re-ataca același loc&#10;```&#10;1. Jucător 1 atacă celula [3, 5]&#10;2. Jucător 1 încearcă să atace din nou [3, 5]&#10;✅ Frontend: Console log &quot;❌ Cell already attacked!&quot;&#10;✅ Backend: Log &quot;Cell already attacked!&quot; + reject&#10;✅ Visual: Cursor &quot;not-allowed&quot; pe celulă&#10;```&#10;&#10;### Test 4: Nu poți plasa navă peste navă&#10;```&#10;1. Plasează Carrier orizontal la [0, 0-4]&#10;2. Încearcă să plasezi Battleship la [0, 2-5]&#10;✅ Expected: Hover arată ROȘU&#10;✅ Expected: canPlace = false&#10;✅ Expected: Click ignorat&#10;✅ Console: &quot;❌ Cannot place ship here - overlaps&quot;&#10;```&#10;&#10;---&#10;&#10;##  Console Logs pentru Debug:&#10;&#10;### Plasare:&#10;- `❌ Cannot place ship here - overlaps with another ship!`&#10;&#10;### Joc:&#10;- ` Board is not clickable - not your turn!`&#10;- `❌ Cell already attacked! {row: X, col: Y, state: 'hit'/'miss'}`&#10;- ` Attacking cell: [row, col]`&#10;- ` Opponent attacked: {...}`&#10;- ` Turn changed: {currentPlayer: ...}`&#10;- ` HIT! Keep the turn: {...}`&#10;&#10;### Backend:&#10;- `HIT! Player X hit Y's ship at [row, col]`&#10;- `HIT! Player X keeps the turn`&#10;- `MISS! Turn switched from X to Y`&#10;- `Player X tried to attack but it's not their turn`&#10;- `Cell already attacked!`&#10;&#10;---&#10;&#10;##  Pentru a testa toate regulile:&#10;&#10;### 1. Recompilează backend:&#10;```bash&#10;cd backend&#10;./gradlew build -x test&#10;./gradlew bootRun&#10;```&#10;&#10;### 2. Testează în 2 tab-uri:&#10;&#10;**Tab 1 - Jucător 1:**&#10;1. Plasează nave (încearcă să suprapui → vezi roșu)&#10;2. Ready&#10;3. Când începe jocul → Atacă&#10;4. Dacă HIT → Vezi că rămâi la tură&#10;5. Dacă MISS → Vezi că tura trece la adversar&#10;6. Când nu e tura ta → Încearcă să apeși (vezi &quot;not-allowed&quot;)&#10;&#10;**Tab 2 - Jucător 2:**&#10;1. Plasează nave&#10;2. Ready&#10;3. Așteaptă tura&#10;4. Când e tura ta → Atacă&#10;5. Încearcă să ataciaceași celulă de 2 ori → Vezi eroare&#10;&#10;Toate regulile sunt implementate și funcționale! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/boardship/boardship_backend/controller/DataSeederController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/boardship/boardship_backend/controller/DataSeederController.java" />
              <option name="updatedContent" value="package com.boardship.backend.controller;&#10;&#10;import com.boardship.backend.model.User;&#10;import com.boardship.backend.service.DataSeederService;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/admin/seed&quot;)&#10;@RequiredArgsConstructor&#10;@CrossOrigin(origins = &quot;*&quot;)&#10;public class DataSeederController {&#10;&#10;    private final DataSeederService dataSeederService;&#10;&#10;    /**&#10;     * Seed random users with match history&#10;     * Example: POST /api/admin/seed/users?count=50&#10;     */&#10;    @PostMapping(&quot;/users&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; seedUsers(@RequestParam(defaultValue = &quot;20&quot;) int count) {&#10;        List&lt;User&gt; users = dataSeederService.seedUsers(count);&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;success&quot;, true);&#10;        response.put(&quot;message&quot;, &quot;Successfully seeded &quot; + users.size() + &quot; users&quot;);&#10;        response.put(&quot;count&quot;, users.size());&#10;        response.put(&quot;users&quot;, users.stream().map(u -&gt; Map.of(&#10;                &quot;username&quot;, u.getUsername(),&#10;                &quot;email&quot;, u.getEmail(),&#10;                &quot;rankingPoints&quot;, u.getRankingPoints()&#10;        )).toList());&#10;        &#10;        return ResponseEntity.ok(response);&#10;    }&#10;&#10;    /**&#10;     * Seed balanced users across skill levels&#10;     * Example: POST /api/admin/seed/balanced?beginners=10&amp;intermediate=10&amp;advanced=10&amp;experts=5&#10;     */&#10;    @PostMapping(&quot;/balanced&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; seedBalancedUsers(&#10;            @RequestParam(defaultValue = &quot;10&quot;) int beginners,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int intermediate,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int advanced,&#10;            @RequestParam(defaultValue = &quot;5&quot;) int experts&#10;    ) {&#10;        dataSeederService.seedBalancedUsers(beginners, intermediate, advanced, experts);&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;success&quot;, true);&#10;        response.put(&quot;message&quot;, &quot;Successfully seeded balanced users&quot;);&#10;        response.put(&quot;breakdown&quot;, Map.of(&#10;                &quot;beginners&quot;, beginners,&#10;                &quot;intermediate&quot;, intermediate,&#10;                &quot;advanced&quot;, advanced,&#10;                &quot;experts&quot;, experts,&#10;                &quot;total&quot;, beginners + intermediate + advanced + experts&#10;        ));&#10;        &#10;        return ResponseEntity.ok(response);&#10;    }&#10;&#10;    /**&#10;     * Clear all users and matches (USE WITH CAUTION)&#10;     * Example: DELETE /api/admin/seed/clear&#10;     */&#10;    @DeleteMapping(&quot;/clear&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; clearAllData() {&#10;        dataSeederService.clearAllData();&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;success&quot;, true);&#10;        response.put(&quot;message&quot;, &quot;All users and matches cleared from database&quot;);&#10;        &#10;        return ResponseEntity.ok(response);&#10;    }&#10;&#10;    /**&#10;     * Quick seed with default values (50 users)&#10;     * Example: POST /api/admin/seed/quick&#10;     */&#10;    @PostMapping(&quot;/quick&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; quickSeed() {&#10;        List&lt;User&gt; users = dataSeederService.seedUsers(50);&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;success&quot;, true);&#10;        response.put(&quot;message&quot;, &quot;Quick seed completed with 50 users&quot;);&#10;        response.put(&quot;count&quot;, users.size());&#10;        &#10;        return ResponseEntity.ok(response);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/boardship/boardship_backend/service/DataSeederService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/boardship/boardship_backend/service/DataSeederService.java" />
              <option name="updatedContent" value="package com.boardship.backend.service;&#10;&#10;import com.boardship.backend.model.Match;&#10;import com.boardship.backend.model.User;&#10;import com.boardship.backend.repository.MatchRepository;&#10;import com.boardship.backend.repository.UserRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.Instant;&#10;import java.time.temporal.ChronoUnit;&#10;import java.util.*;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class DataSeederService {&#10;    private final UserRepository userRepository;&#10;    private final MatchRepository matchRepository;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    private static final String[] FIRST_NAMES = {&#10;            &quot;Alex&quot;, &quot;Maria&quot;, &quot;Ion&quot;, &quot;Elena&quot;, &quot;Andrei&quot;, &quot;Ioana&quot;, &quot;Mihai&quot;, &quot;Ana&quot;,&#10;            &quot;George&quot;, &quot;Diana&quot;, &quot;Cristian&quot;, &quot;Laura&quot;, &quot;Adrian&quot;, &quot;Andreea&quot;, &quot;Bogdan&quot;,&#10;            &quot;Raluca&quot;, &quot;Vlad&quot;, &quot;Carmen&quot;, &quot;Dan&quot;, &quot;Monica&quot;, &quot;Florin&quot;, &quot;Alina&quot;,&#10;            &quot;Stefan&quot;, &quot;Irina&quot;, &quot;Marius&quot;, &quot;Roxana&quot;, &quot;Radu&quot;, &quot;Gabriela&quot;, &quot;Catalin&quot;,&#10;            &quot;Simona&quot;, &quot;Ciprian&quot;, &quot;Daniela&quot;, &quot;Iulian&quot;, &quot;Bianca&quot;, &quot;Razvan&quot;, &quot;Oana&quot;&#10;    };&#10;&#10;    private static final String[] LAST_NAMES = {&#10;            &quot;Popescu&quot;, &quot;Ionescu&quot;, &quot;Popa&quot;, &quot;Radu&quot;, &quot;Dumitrescu&quot;, &quot;Munteanu&quot;,&#10;            &quot;Stan&quot;, &quot;Stoica&quot;, &quot;Gheorghe&quot;, &quot;Dima&quot;, &quot;Constantin&quot;, &quot;Oprea&quot;,&#10;            &quot;Barbu&quot;, &quot;Nistor&quot;, &quot;Florea&quot;, &quot;Diaconu&quot;, &quot;Cristea&quot;, &quot;Stanciu&quot;,&#10;            &quot;Marin&quot;, &quot;Tudor&quot;, &quot;Lazar&quot;, &quot;Matei&quot;, &quot;Rusu&quot;, &quot;Ungureanu&quot;&#10;    };&#10;&#10;    private static final String[] GAME_MODES = {&quot;ranked&quot;, &quot;casual&quot;, &quot;blitz&quot;};&#10;&#10;    private final Random random = new Random();&#10;&#10;    /**&#10;     * Generate multiple users with random match history and ranking points&#10;     *&#10;     * @param count Number of users to create&#10;     * @return List of created users&#10;     */&#10;    public List&lt;User&gt; seedUsers(int count) {&#10;        log.info(&quot;Starting to seed {} users with random match history&quot;, count);&#10;        List&lt;User&gt; createdUsers = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; count; i++) {&#10;            try {&#10;                String username = generateUniqueUsername();&#10;                String email = username.toLowerCase() + &quot;@boardship.com&quot;;&#10;&#10;                // Check if user already exists&#10;                if (userRepository.existsByEmail(email)) {&#10;                    log.warn(&quot;User with email {} already exists, skipping&quot;, email);&#10;                    continue;&#10;                }&#10;&#10;                // Create user with initial RP between 800-1200&#10;                User user = User.builder()&#10;                        .username(username)&#10;                        .email(email)&#10;                        .password(passwordEncoder.encode(&quot;password123&quot;))&#10;                        .role(&quot;USER&quot;)&#10;                        .status(&quot;offline&quot;)&#10;                        .lastSeen(Instant.now().minus(random.nextInt(7), ChronoUnit.DAYS))&#10;                        .themePreference(&quot;dark&quot;)&#10;                        .sessionToken(null)&#10;                        .rankingPoints(800 + random.nextInt(400))&#10;                        .build();&#10;&#10;                user = userRepository.save(user);&#10;                createdUsers.add(user);&#10;&#10;                // Generate random match history for this user&#10;                generateMatchHistory(user);&#10;&#10;                log.info(&quot;Created user: {} with email: {} and {} RP&quot;, &#10;                        user.getUsername(), user.getEmail(), user.getRankingPoints());&#10;&#10;            } catch (Exception e) {&#10;                log.error(&quot;Error creating user {}: {}&quot;, i, e.getMessage());&#10;            }&#10;        }&#10;&#10;        log.info(&quot;Successfully seeded {} users&quot;, createdUsers.size());&#10;        return createdUsers;&#10;    }&#10;&#10;    /**&#10;     * Generate random match history for a user&#10;     */&#10;    private void generateMatchHistory(User user) {&#10;        // Random number of matches between 10 and 50&#10;        int matchCount = 10 + random.nextInt(41);&#10;        int currentRP = user.getRankingPoints();&#10;&#10;        List&lt;User&gt; allUsers = userRepository.findAll();&#10;        List&lt;User&gt; potentialOpponents = allUsers.stream()&#10;                .filter(u -&gt; !u.getId().equals(user.getId()))&#10;                .toList();&#10;&#10;        if (potentialOpponents.isEmpty()) {&#10;            // If no opponents, create some bot opponents&#10;            potentialOpponents = List.of(&#10;                    User.builder().id(&quot;bot1&quot;).username(&quot;Bot_Alpha&quot;).build(),&#10;                    User.builder().id(&quot;bot2&quot;).username(&quot;Bot_Beta&quot;).build(),&#10;                    User.builder().id(&quot;bot3&quot;).username(&quot;Bot_Gamma&quot;).build()&#10;            );&#10;        }&#10;&#10;        List&lt;Match&gt; matches = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; matchCount; i++) {&#10;            User opponent = potentialOpponents.get(random.nextInt(potentialOpponents.size()));&#10;            &#10;            // Random date within last 60 days&#10;            Instant playedAt = Instant.now().minus(random.nextInt(60), ChronoUnit.DAYS)&#10;                    .minus(random.nextInt(24), ChronoUnit.HOURS);&#10;&#10;            // Random result (60% win rate for variety)&#10;            boolean won = random.nextDouble() &lt; 0.6;&#10;            String result = won ? &quot;won&quot; : &quot;lost&quot;;&#10;&#10;            // Calculate points change based on mode and result&#10;            String mode = GAME_MODES[random.nextInt(GAME_MODES.length)];&#10;            int basePoints = mode.equals(&quot;ranked&quot;) ? 25 : (mode.equals(&quot;blitz&quot;) ? 15 : 10);&#10;            int pointsChange = won ? &#10;                    (basePoints + random.nextInt(10)) : &#10;                    -(basePoints + random.nextInt(10));&#10;&#10;            if (!mode.equals(&quot;ranked&quot;)) {&#10;                pointsChange = pointsChange / 2; // Less points for non-ranked&#10;            }&#10;&#10;            currentRP += pointsChange;&#10;            currentRP = Math.max(0, currentRP); // Don't go below 0&#10;&#10;            // Random score (10-0 to 10-9)&#10;            int playerScore = won ? 10 : random.nextInt(10);&#10;            int opponentScore = won ? random.nextInt(10) : 10;&#10;            String score = playerScore + &quot;-&quot; + opponentScore;&#10;&#10;            // Random duration (5-30 minutes)&#10;            int durationSeconds = (5 + random.nextInt(26)) * 60;&#10;&#10;            Match match = Match.builder()&#10;                    .playerId(user.getId())&#10;                    .playerUsername(user.getUsername())&#10;                    .opponentId(opponent.getId())&#10;                    .opponentUsername(opponent.getUsername())&#10;                    .mode(mode)&#10;                    .result(result)&#10;                    .score(score)&#10;                    .pointsChange(pointsChange)&#10;                    .durationSeconds(durationSeconds)&#10;                    .playedAt(playedAt)&#10;                    .build();&#10;&#10;            matches.add(match);&#10;&#10;            // Also create the opponent's perspective of the match&#10;            if (!opponent.getId().startsWith(&quot;bot&quot;)) {&#10;                Match opponentMatch = Match.builder()&#10;                        .playerId(opponent.getId())&#10;                        .playerUsername(opponent.getUsername())&#10;                        .opponentId(user.getId())&#10;                        .opponentUsername(user.getUsername())&#10;                        .mode(mode)&#10;                        .result(won ? &quot;lost&quot; : &quot;won&quot;)&#10;                        .score(opponentScore + &quot;-&quot; + playerScore)&#10;                        .pointsChange(-pointsChange)&#10;                        .durationSeconds(durationSeconds)&#10;                        .playedAt(playedAt)&#10;                        .build();&#10;                matches.add(opponentMatch);&#10;            }&#10;        }&#10;&#10;        // Save all matches&#10;        matchRepository.saveAll(matches);&#10;&#10;        // Update user's final RP&#10;        user.setRankingPoints(currentRP);&#10;        userRepository.save(user);&#10;&#10;        log.info(&quot;Generated {} matches for user {}, final RP: {}&quot;, &#10;                matchCount, user.getUsername(), currentRP);&#10;    }&#10;&#10;    /**&#10;     * Generate a unique username&#10;     */&#10;    private String generateUniqueUsername() {&#10;        String username;&#10;        int attempts = 0;&#10;        do {&#10;            String firstName = FIRST_NAMES[random.nextInt(FIRST_NAMES.length)];&#10;            String lastName = LAST_NAMES[random.nextInt(LAST_NAMES.length)];&#10;            int number = random.nextInt(1000);&#10;            username = firstName + lastName + number;&#10;            attempts++;&#10;        } while (userRepository.existsByUsernameIgnoreCase(username) &amp;&amp; attempts &lt; 100);&#10;&#10;        if (attempts &gt;= 100) {&#10;            // Fallback to UUID-based username&#10;            username = &quot;User&quot; + UUID.randomUUID().toString().substring(0, 8);&#10;        }&#10;&#10;        return username;&#10;    }&#10;&#10;    /**&#10;     * Clear all seeded data (users and matches)&#10;     */&#10;    public void clearAllData() {&#10;        log.warn(&quot;Clearing all users and matches from database&quot;);&#10;        matchRepository.deleteAll();&#10;        userRepository.deleteAll();&#10;        log.info(&quot;All data cleared&quot;);&#10;    }&#10;&#10;    /**&#10;     * Seed a specific number of users with balanced skill levels&#10;     */&#10;    public void seedBalancedUsers(int beginners, int intermediate, int advanced, int experts) {&#10;        log.info(&quot;Seeding balanced users: {} beginners, {} intermediate, {} advanced, {} experts&quot;,&#10;                beginners, intermediate, advanced, experts);&#10;&#10;        seedUsersWithRPRange(beginners, 500, 900);&#10;        seedUsersWithRPRange(intermediate, 900, 1300);&#10;        seedUsersWithRPRange(advanced, 1300, 1700);&#10;        seedUsersWithRPRange(experts, 1700, 2500);&#10;    }&#10;&#10;    private void seedUsersWithRPRange(int count, int minRP, int maxRP) {&#10;        for (int i = 0; i &lt; count; i++) {&#10;            try {&#10;                String username = generateUniqueUsername();&#10;                String email = username.toLowerCase() + &quot;@boardship.com&quot;;&#10;&#10;                if (userRepository.existsByEmail(email)) {&#10;                    continue;&#10;                }&#10;&#10;                int initialRP = minRP + random.nextInt(maxRP - minRP);&#10;&#10;                User user = User.builder()&#10;                        .username(username)&#10;                        .email(email)&#10;                        .password(passwordEncoder.encode(&quot;password123&quot;))&#10;                        .role(&quot;USER&quot;)&#10;                        .status(&quot;offline&quot;)&#10;                        .lastSeen(Instant.now().minus(random.nextInt(7), ChronoUnit.DAYS))&#10;                        .themePreference(random.nextBoolean() ? &quot;dark&quot; : &quot;light&quot;)&#10;                        .sessionToken(null)&#10;                        .rankingPoints(initialRP)&#10;                        .build();&#10;&#10;                user = userRepository.save(user);&#10;                generateMatchHistory(user);&#10;&#10;            } catch (Exception e) {&#10;                log.error(&quot;Error creating user in range {}-{}: {}&quot;, minRP, maxRP, e.getMessage());&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>